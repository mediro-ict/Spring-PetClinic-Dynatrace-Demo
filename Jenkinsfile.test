#!/usr/bin/env groovy

 //parameters: [file(name: "$workspace/testMatchRules.txt")]

 
import groovy.json.JsonSlurper
def dockerImage


//env.tagMatchRules

//def tagMatchRules = Eval.me(params.tagMatchRules)

//def tagMatchRule = readFile('$workspace/testMatchRules.txt')
//def tagMatchRules 
 /*[
    [
        meTypes: [
            [meType: 'SERVICE']
        ], 
            tags: [
                [context: 'CONTEXTLESS', key: 'servername', value: 'Tomcat/localhost']
            ]
    ]
]*/

@NonCPS
def jsonParse(def json) {
    new groovy.json.JsonSlurperClassic().parseText(json)
}

pipeline {
    environment {
    registry = "leonvzd/spring-petclinic:latest"
    registryCredential = 'dockerHubCredentials'
    dockerImage = ''
    def tagMatchRules = readFile('testMatchRules.txt')

  }
    agent {
        label 'docker'
    }
    options {
        ansiColor('xterm')
        timestamps()
        timeout(30)
        disableConcurrentBuilds()
        buildDiscarder logRotator(numToKeepStr: '10')
    }
    triggers {
        cron '@daily'
    }

    stages {
        stage('Maven Build') {
            steps {
                script {
                    docker.image('maven:3-jdk-8-slim').inside {
                        sh 'mvn clean package --batch-mode'
                    }
                }
//                publishCoverage adapters: [jacocoAdapter('target/jacoco.exec')]
//                findbugs pattern: '**/target/findbugsXml.xml'
//                checkstyle pattern: '**/target/checkstyle-result.xml'
//                junit allowEmptyResults: true, testResults: '**/target/surefire-reports/**/*.xml'
                archiveArtifacts artifacts: '**/target/*.jar,**/target/*.war', fingerprint: true
            }
        }
        stage('Docker Build') {
            steps {
                script {
                    dockerImage = docker.build registry
                }
            }
        }
        stage('Deploy to Staging Server') {
            steps {
               
                echo tagMatchRules
                script {
             //   createDynatraceDeploymentEvent(envId: 'cloud', tagMatchRules: tagMatchRules) {
                    createDynatraceDeploymentEvent(envId: 'cloud', tagMatchRules:Eval.me("${env.tagMatchRules}")) {
                        //sh 'docker-compose down'
                        sh 'docker-compose up -d'
                    }
                }
            }
        }
        stage('Create Dynatrace Tags'){
         /*This stage is to make sure the performance signature plugin targets the correct services being tested by the gatling scripts
         The stage will connect to the Dynatrace API check that the services being tested from the SIMULATION_SERVICES job parameter are 
         tagged with the Jenkins Jobname. If the Tag does not exist it will tag the service specified with the Jenkins Jobname.
         */
         steps {
         
         script{
         String[] serviceSplit = env.SIMULATION_SERVICES.split(",")
         for (int i = 0; i < serviceSplit.size(); i++) {
       
    
         def encodedString = URLEncoder.encode(serviceSplit[i], "UTF-8")    

         def services = httpRequest acceptType: 'APPLICATION_JSON', contentType: 'APPLICATION_JSON', customHeaders: [[maskValue: true, name: 'Authorization', value: 'Api-Token HVV-Ubw-QDudjy0WadMLB']], responseHandle: 'STRING', url: "https://hky02010.live.dynatrace.com/api/v1/entity/services?tag=${encodedString}&includeDetails=false"

         println services.getContent()
         def list = new JsonSlurper().parseText( services.getContent() )

         // Print them out to make sure
        list.each { println it }
        def description = "balls"
        def bodString = '{"tags": ["asdasdasd"]}'
        def patchOrg = """
                 {"description": "$description"}
                 """
        patchOrg = jsonParse(patchOrg)         
        def response = httpRequest acceptType: 'APPLICATION_JSON', contentType: 'APPLICATION_JSON', httpMode: 'PATCH', requestBody: patchOrg, url: "https://api.github.com/orgs/balls"
        
        

        List tags = list.tags
        if (tags.contains(env.SIMULATION_CLASS)){
         
         println("Simulation Class found")
         
        } 
        else {
            
           // response = httpRequest consoleLogResponseBody: true, contentType: 'APPLICATION_JSON', httpMode: 'POST', requestBody: body, url: "https://${host}", validResponseCodes: '200'
        //def createTag = httpRequest customHeaders: [[maskValue: true, name: 'Authorization', value: 'Api-Token HVV-Ubw-QDudjy0WadMLB']], httpMode: 'POST', requestBody: 'data', responseHandle: 'NONE', url: 'https://hky02010.live.dynatrace.com/api/v1/entity/services/SERVICE-1B18EBC6BCD86B7C'

        }

        println(tags)   


         }
         }
         }
        }
        stage('Performance Test') {
            steps {

                script {
                recordDynatraceSession(envId: 'cloud', testCase: 'loadtest',tagMatchRules:Eval.me("${env.tagMatchRules}")) {
                //    performanceTest(readFile('performanceTest.json'))
                     bzt "blaze.yml"
                }
                perfSigDynatraceReports envId: 'cloud', specFile: 'specfile.json', nonFunctionalFailure: 2
                }  
            }
        }
       /** stage('Docker Push') {
            steps {
                 echo 'Docker Push!'
                 script {
                    docker.withRegistry('', registryCredential) {
                        dockerImage.push()
                    }
                } 
            }
        } **/
       /** stage('deploy to Production') {
            steps {
                echo 'deploy to Production!'
            }
        } **/
    }
    post {
        always {
          echo 'done!'  
//          step([$class: 'Mailer', notifyEveryUnstableBuild: true, recipients: 'notify@me', sendToIndividuals: false])
        }
    }
}