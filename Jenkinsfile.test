#!/usr/bin/env groovy

 //parameters: [file(name: "$workspace/testMatchRules.txt")]

 
import groovy.json.JsonSlurper
def dockerImage


//env.tagMatchRules

//def tagMatchRules = Eval.me(params.tagMatchRules)

//def tagMatchRule = readFile('$workspace/testMatchRules.txt')
//def tagMatchRules 
 /*[
    [
        meTypes: [
            [meType: 'SERVICE']
        ], 
            tags: [
                [context: 'CONTEXTLESS', key: 'servername', value: 'Tomcat/localhost']
            ]
    ]
]*/

pipeline {
    environment {
    registry = "leonvzd/spring-petclinic:latest"
    registryCredential = 'dockerHubCredentials'
    dockerImage = ''
    def tagMatchRules = readFile('testMatchRules.txt')

  }
    agent {
        label 'docker'
    }
    options {
        ansiColor('xterm')
        timestamps()
        timeout(30)
        disableConcurrentBuilds()
        buildDiscarder logRotator(numToKeepStr: '10')
    }
    triggers {
        cron '@daily'
    }

    stages {
        stage('Maven Build') {
            steps {
                script {
                    docker.image('maven:3-jdk-8-slim').inside {
                        sh 'mvn clean package --batch-mode'
                    }
                }
//                publishCoverage adapters: [jacocoAdapter('target/jacoco.exec')]
//                findbugs pattern: '**/target/findbugsXml.xml'
//                checkstyle pattern: '**/target/checkstyle-result.xml'
//                junit allowEmptyResults: true, testResults: '**/target/surefire-reports/**/*.xml'
                archiveArtifacts artifacts: '**/target/*.jar,**/target/*.war', fingerprint: true
            }
        }
        stage('Docker Build') {
            steps {
                script {
                    dockerImage = docker.build registry
                }
            }
        }
        stage('Deploy to Staging Server') {
            steps {
               
                echo tagMatchRules
                script {
             //   createDynatraceDeploymentEvent(envId: 'cloud', tagMatchRules: tagMatchRules) {
                    createDynatraceDeploymentEvent(envId: 'cloud', tagMatchRules:Eval.me("${env.tagMatchRules}")) {
                        //sh 'docker-compose down'
                        sh 'docker-compose up -d'
                    }
                }
            }
        }
        stage('Create Dynatrace Tags'){
         /*This stage is to make sure the performance signature plugin targets the correct services being tested by the gatling scripts
         The stage will connect to the Dynatrace API check that the services being tested from the SIMULATION_SERVICES job parameter are 
         tagged with the Jenkins Jobname. If the Tag does not exist it will tag the service specified with the Jenkins Jobname.
         */
         steps {
         script{    
         def services = httpRequest acceptType: 'APPLICATION_JSON', contentType: 'APPLICATION_JSON', customHeaders: [[maskValue: true, name: 'Authorization', value: 'Api-Token oN43XTDaTPC8pTBfygxEf']], responseHandle: 'STRING', url: 'https://gtn866.dynatrace-managed.com/e/5938dff2-94b9-4ffd-b14d-f2de4daa7dfb/api/v1/entity/services?tag=WebServiceName%3ACreateEventRestProvider&includeDetails=false'

         println services.contents
         def list = new JsonSlurper().parseText( services.contents )

         // Print them out to make sure
        list.each { println it }
         }
         }
        }
        stage('Performance Test') {
            steps {

                script {
                recordDynatraceSession(envId: 'cloud', testCase: 'loadtest',tagMatchRules:Eval.me("${env.tagMatchRules}")) {
                //    performanceTest(readFile('performanceTest.json'))
                     bzt "blaze.yml"
                }
                perfSigDynatraceReports envId: 'cloud', specFile: 'specfile.json', nonFunctionalFailure: 2
                }  
            }
        }
       /** stage('Docker Push') {
            steps {
                 echo 'Docker Push!'
                 script {
                    docker.withRegistry('', registryCredential) {
                        dockerImage.push()
                    }
                } 
            }
        } **/
       /** stage('deploy to Production') {
            steps {
                echo 'deploy to Production!'
            }
        } **/
    }
    post {
        always {
          echo 'done!'  
//          step([$class: 'Mailer', notifyEveryUnstableBuild: true, recipients: 'notify@me', sendToIndividuals: false])
        }
    }
}